1. Big O
    1) O(1)

    2) O(n)

2. Even or Odd
    O(1), because there are no loops
    Algorithm time is independent of the input

3. Are you here?
    O(n^2), nested for-loops
    it is iterating through every element of an array then comparing it and iterating through another array (n*n)
    The complexity is being increased by a factor of the second array's length

4. Doubler
    O(n), one for-loop only iterating through one array. 

5. Naive search
    O(n), one for-loop only iterating through one array.

6. Creating pairs
    O(n^2), one array, two for-loops nested

7. Compute the sequence
    creates a fibonacci sequence up to num amount of numbers, O(n) because the run-time is depender on the input number-- the higher the input, the longer it will take. It increases linearly.

8. An Efficent search
    O(log(n)) when the input significantly increases, the output does not. It does not check every element to succeed.

9. 